{"remainingRequest":"/home/sarah/cesiumjs/vue3.0_cesium_project/node_modules/babel-loader/lib/index.js!/home/sarah/cesiumjs/vue3.0_cesium_project/node_modules/vue-loader-v16/dist/templateLoader.js??ref--6!/home/sarah/cesiumjs/vue3.0_cesium_project/node_modules/cache-loader/dist/cjs.js??ref--0-0!/home/sarah/cesiumjs/vue3.0_cesium_project/node_modules/vue-loader-v16/dist/index.js??ref--0-1!/home/sarah/cesiumjs/vue3.0_cesium_project/src/components/HelloWorld.vue?vue&type=template&id=469af010&scoped=true","dependencies":[{"path":"/home/sarah/cesiumjs/vue3.0_cesium_project/src/components/HelloWorld.vue","mtime":1664791458989},{"path":"/home/sarah/cesiumjs/vue3.0_cesium_project/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/sarah/cesiumjs/vue3.0_cesium_project/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/sarah/cesiumjs/vue3.0_cesium_project/node_modules/vue-loader-v16/dist/templateLoader.js","mtime":1632349277000},{"path":"/home/sarah/cesiumjs/vue3.0_cesium_project/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/sarah/cesiumjs/vue3.0_cesium_project/node_modules/vue-loader-v16/dist/index.js","mtime":1632349277000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IHsgY3JlYXRlRWxlbWVudFZOb2RlIGFzIF9jcmVhdGVFbGVtZW50Vk5vZGUsIG9wZW5CbG9jayBhcyBfb3BlbkJsb2NrLCBjcmVhdGVFbGVtZW50QmxvY2sgYXMgX2NyZWF0ZUVsZW1lbnRCbG9jaywgcHVzaFNjb3BlSWQgYXMgX3B1c2hTY29wZUlkLCBwb3BTY29wZUlkIGFzIF9wb3BTY29wZUlkIH0gZnJvbSAidnVlIjsKCnZhciBfd2l0aFNjb3BlSWQgPSBmdW5jdGlvbiBfd2l0aFNjb3BlSWQobikgewogIHJldHVybiBfcHVzaFNjb3BlSWQoImRhdGEtdi00NjlhZjAxMCIpLCBuID0gbigpLCBfcG9wU2NvcGVJZCgpLCBuOwp9OwoKdmFyIF9ob2lzdGVkXzEgPSB7CiAgaWQ6ICJjb250YWluZXIiCn07CmV4cG9ydCBmdW5jdGlvbiByZW5kZXIoX2N0eCwgX2NhY2hlLCAkcHJvcHMsICRzZXR1cCwgJGRhdGEsICRvcHRpb25zKSB7CiAgcmV0dXJuIF9vcGVuQmxvY2soKSwgX2NyZWF0ZUVsZW1lbnRCbG9jaygiZGl2IiwgX2hvaXN0ZWRfMSwgW19jcmVhdGVFbGVtZW50Vk5vZGUoImJ1dHRvbiIsIHsKICAgIG9uQ2xpY2s6IF9jYWNoZVswXSB8fCAoX2NhY2hlWzBdID0gZnVuY3Rpb24gKCRldmVudCkgewogICAgICByZXR1cm4gX2N0eC5leHBvcnRDb29yZERldGFpbHMoKTsKICAgIH0pCiAgfSwgIiBFeHBvcnQgIildKTsKfQ=="},{"version":3,"sources":["/home/sarah/cesiumjs/vue3.0_cesium_project/src/components/HelloWorld.vue"],"names":[],"mappings":";;;;;;;AACO,EAAA,EAAE,EAAC;;;uBAAR,mBAAA,CAIM,KAJN,EAAA,UAAA,EAIM,CAHJ,mBAAA,CAES,QAFT,EAES;AAFA,IAAA,OAAK,EAAA,MAAA,CAAA,CAAA,CAAA,KAAA,MAAA,CAAA,CAAA,CAAA,GAAA,UAAA,MAAA;AAAA,aAAE,IAAA,CAAA,kBAAA,EAAF;AAAA,KAAA;AAEL,GAFT,EAAsC,UAAtC,CAGI,CAJN,C","sourcesContent":["<template>\n  <div id=\"container\">\n    <button @click=\"exportCoordDetails()\">\n        Export\n    </button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'vue3.0_cesium_project',\n  data() {\n    return {\n      // ellipsoid: Cesium.Ellipsoid.WGS84,\n      geodesic: new Cesium.EllipsoidGeodesic(),\n    };\n  },\n  async mounted() {\n    this.load3DTileset();\n  },\n  methods: {\n    load3DTileset() {\n      Cesium.Ion.defaultAccessToken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1ZjU3ZWUzMS0yMTJiLTRmNjUtYjE1YS0yYTU2MjQwOWEwZGIiLCJpZCI6MTA5OTA0LCJpYXQiOjE2NjQ3Mjc0Njh9.jYUr3jpVl2YzqB4MY1A0-KtWqxnp6sHcbyBdMH_RECc\";\n      var viewer = new Cesium.Viewer('container', {\n        // the following options is for self define button's \n        // show/no show in the viewer\n        geocoder: false,\n        homeButton: false,\n        sceneModePicker: false,\n        baseLayerPicker: false,\n        navigationHelpButton: true,\n        animation: false,\n        timeline: false,\n        fullscreenButton: true,\n        vrButton: false,\n        shadows: false,\n        infoBox: false,\n        CreditsDisplay: false,\n        terrainProvider: new Cesium.CesiumTerrainProvider({\n          url: Cesium.IonResource.fromAssetId(1),\n        }),\n      });\n      viewer.scene.globe.depthTestAgainstTerrain = true;\n      var camera = viewer.camera;\n      var scene = viewer.scene;\n      // var globe = scene.globe;\n      var ellipsoid = Cesium.Ellipsoid.WGS84;\n      // var geodesic = new Cesium.EllipsoidGeodesic();\n      var tm_url = Cesium.IonResource.fromAssetId(1340967);\n      var tm = new Cesium.Cesium3DTileset({\n        url: tm_url,\n      })\n      var tileset = scene.primitives.add(tm);\n      // remove the logo\n      viewer._cesiumWidget._creditContainer.style.display = \"none\";\n      // var tm_url = Cesium.IonResource.fromAssetId(1340967);\n      // var tm = new Cesium.Cesium3DTileset({\n      //   url: tm_url,\n      //   // controlling the destop's GPU's memory's using,\n      //   // so that i worn't crash because of the low GPU memory \n      //   modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(\n      //       Cesium.Cartesian3.fromDegrees(0, 0)\n      //     ),\n      // })\n      // var tileset = viewer.scene.primitives.add(tm)\n      // // viewer.zoomTo(tm)\n      // viewer.flyTo(tm) // fly to much cool\n      tileset.readyPromise.then(function() {\n        // console.log(tileset);\n        var boundingSphere = tileset.boundingSphere;\n        camera.viewBoundingSphere(boundingSphere, new Cesium.HeadingPitchRange(0.5, -0.2, boundingSphere.radius * 4.0));\n        camera.lookAtTransform(Cesium.Matrix4.IDENTITY);\n        viewer.zoomTo(tileset);\n      }).otherwise(function(error) {\n        throw(error);\n      });\n      tileset.allTilesLoaded.addEventListener(function() {\n        console.log('All tiles are loaded');\n      });\n      \n      var points = scene.primitives.add(new Cesium.PointPrimitiveCollection());\n      var point1, point2;\n      var point1GeoPosition, point2GeoPosition;\n      var polylines = scene.primitives.add(new Cesium.PolylineCollection());\n      var polyline1, polyline2, polyline3;\n      var distanceLabel, verticalLabel, horizontalLabel;\n      var LINEPOINTCOLOR = Cesium.Color.RED;\n      // var labels = scene.primitives.add(new Cesium.LabelCollection({scene: scene}));\n\n      // Mouse over the globe to see the cartographic position\n      var vueComponent = this;\n      var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n      handler.setInputAction(function(click) {\n          // console.log(click);\n          if (scene.mode !== Cesium.SceneMode.MORPHING) {\n              // console.log(vueComponent.geodesic);\n              var pickedObject = scene.pick(click.position);\n              if (scene.pickPositionSupported && Cesium.defined(pickedObject)) {\n                  var cartesian = viewer.scene.pickPosition(click.position);\n                  // console.log(cartesian);\n                  if (Cesium.defined(cartesian)) {\n                      if (points.length === 2) {\n                          points.removeAll();\n                          polylines.removeAll();\n                          viewer.entities.removeAll();\n                          // viewer.entities.remove(distanceLabel);\n                          // viewer.entities.remove(horizontalLabel);\n                          // viewer.entities.remove(verticalLabel);\n                      }\n                      //add first point\n                      if (points.length === 0) {\n                          point1 = points.add({\n                              position : new Cesium.Cartesian3(cartesian.x, cartesian.y, cartesian.z),\n                              color : LINEPOINTCOLOR\n                          });\n                      } //add second point and lines\n                      else if (points.length === 1) {\n                          point2 = points.add({\n                              position : new Cesium.Cartesian3(cartesian.x, cartesian.y, cartesian.z),\n                              color : LINEPOINTCOLOR\n                          }); \n                          point1GeoPosition = Cesium.Cartographic.fromCartesian(point1.position);\n                          point2GeoPosition = Cesium.Cartographic.fromCartesian(point2.position);\n                          // point3GeoPosition = Cesium.Cartographic.fromCartesian(new Cesium.Cartesian3(point2.position.x, point2.position.y, point1.position.z));  \n\n                          var pl1Positions = [\n                            new Cesium.Cartesian3.fromRadians(point1GeoPosition.longitude, point1GeoPosition.latitude, point1GeoPosition.height),\n                            new Cesium.Cartesian3.fromRadians(point2GeoPosition.longitude, point2GeoPosition.latitude, point2GeoPosition.height)\n                          ];\n                          var pl2Positions = [\n                            new Cesium.Cartesian3.fromRadians(point2GeoPosition.longitude, point2GeoPosition.latitude, point2GeoPosition.height),\n                            new Cesium.Cartesian3.fromRadians(point2GeoPosition.longitude, point2GeoPosition.latitude, point1GeoPosition.height)\n                          ];\n                          var pl3Positions = [\n                            new Cesium.Cartesian3.fromRadians(point1GeoPosition.longitude, point1GeoPosition.latitude, point1GeoPosition.height),\n                            new Cesium.Cartesian3.fromRadians(point2GeoPosition.longitude, point2GeoPosition.latitude, point1GeoPosition.height)\n                          ];\n\n                          polyline1 = polylines.add({\n                            show : true,\n                            positions : pl1Positions,\n                            width : 1,\n                            material: new Cesium.Material({\n                                fabric : {\n                                    type : 'Color',\n                                    uniforms : {\n                                        color : LINEPOINTCOLOR\n                                    }\n                                }\n                            })\n                          }); \n                          polyline2 = polylines.add({\n                            show : true,\n                            positions : pl2Positions,\n                            width : 1,\n                            material: new Cesium.Material({\n                                fabric : {\n                                    type : 'PolylineDash',\n                                    uniforms : {\n                                        color : LINEPOINTCOLOR,\n                                    }\n                                },\n                            })\n                          });\n                          polyline3 = polylines.add({\n                            show : true,\n                            positions : pl3Positions,\n                            width : 1,\n                            material: new Cesium.Material({\n                                fabric : {\n                                    type : 'PolylineDash',\n                                    uniforms : {\n                                        color : LINEPOINTCOLOR,\n                                    }\n                                },\n                            })\n                          }); \n                          var labelZ;\n                          if (point2GeoPosition.height >= point1GeoPosition.height) {\n                            labelZ = point1GeoPosition.height + (point2GeoPosition.height - point1GeoPosition.height)/2.0;\n                          } else {\n                            labelZ = point2GeoPosition.height + (point1GeoPosition.height - point2GeoPosition.height)/2.0;\n                          };\n\n                          distanceLabel, horizontalLabel, verticalLabel = vueComponent.addDistanceLabel(point1, point2, labelZ, viewer, point1GeoPosition , point2GeoPosition, ellipsoid, horizontalLabel, distanceLabel, verticalLabel);\n\n                      }\n                  }\n              }\n          }\n      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n    },\n    addDistanceLabel(point1, point2, height, viewer, point1GeoPosition, point2GeoPosition, ellipsoid, horizontalLabel, distanceLabel, verticalLabel) {\n      var label = {\n        font : '12px monospace',\n        showBackground : true,\n        horizontalOrigin : Cesium.HorizontalOrigin.CENTER,\n        verticalOrigin : Cesium.VerticalOrigin.CENTER,\n        pixelOffset : new Cesium.Cartesian2(0, 0),\n        eyeOffset: new Cesium.Cartesian3(0,0,-50),\n        fillColor: Cesium.Color.WHITE,\n      };\n      point1.cartographic = ellipsoid.cartesianToCartographic(point1.position);\n      point2.cartographic = ellipsoid.cartesianToCartographic(point2.position);\n      point1.longitude = parseFloat(Cesium.Math.toDegrees(point1.position.x));\n      point1.latitude = parseFloat(Cesium.Math.toDegrees(point1.position.y));\n      point2.longitude = parseFloat(Cesium.Math.toDegrees(point2.position.x));\n      point2.latitude = parseFloat(Cesium.Math.toDegrees(point2.position.y));\n      label.text = '('+point1GeoPosition.latitude+','+point1GeoPosition.longitude+') \\n'+ this.getHorizontalDistanceString(point1, point2);\n      console.log(point1GeoPosition);\n      horizontalLabel = viewer.entities.add({\n          position: this.getMidpoint(point1, point2, point1GeoPosition.height),\n          label: label\n      });\n      label.text = '('+point1GeoPosition.latitude+','+point1GeoPosition.longitude+') \\n'+ this.getDistanceString(point1, point2, point1GeoPosition, point2GeoPosition);\n      distanceLabel = viewer.entities.add({\n          position: this.getMidpoint(point1, point2, height),\n          label: label\n      });\n      label.text = '('+point1GeoPosition.latitude+','+point1GeoPosition.longitude+') \\n'+ this.getVerticalDistanceString(point1GeoPosition, point2GeoPosition);\n      verticalLabel = viewer.entities.add({\n          position: this.getMidpoint(point2, point2, height),\n          label: label\n      });\n      return distanceLabel, horizontalLabel, verticalLabel;\n    },\n    getHorizontalDistanceString(point1, point2) {\n      this.geodesic.setEndPoints(point1.cartographic, point2.cartographic);\n      var meters = this.geodesic.surfaceDistance.toFixed(2);\n      if (meters >= 1000) {\n          return (meters / 1000).toFixed(1) + ' KM';\n      }\n      return meters + ' M';\n    },\n    getVerticalDistanceString(point1GeoPosition, point2GeoPosition) {\n      var heights = [point1GeoPosition.height, point2GeoPosition.height];\n      var meters = Math.max.apply(Math, heights) - Math.min.apply(Math, heights);\n      if (meters >= 1000) {\n          return (meters / 1000).toFixed(1) + ' KM';\n      }\n      return meters.toFixed(2) + ' M';\n    },\n    getDistanceString(point1, point2, point1GeoPosition, point2GeoPosition) {\n      this.geodesic.setEndPoints(point1.cartographic, point2.cartographic);\n      var horizontalMeters = this.geodesic.surfaceDistance.toFixed(2);\n      var heights = [point1GeoPosition.height, point2GeoPosition.height];\n      var verticalMeters = Math.max.apply(Math, heights) - Math.min.apply(Math, heights);\n      var meters = Math.pow((Math.pow(horizontalMeters, 2) + Math.pow(verticalMeters, 2)), 0.5);\n\n      if (meters >= 1000) {\n          return (meters / 1000).toFixed(1) + ' KM';\n      }\n      return meters.toFixed(2) + ' M';\n    },\n    getMidpoint(point1, point2, height) {\n      var scratch = new Cesium.Cartographic();\n      this.geodesic.setEndPoints(point1.cartographic, point2.cartographic);\n      var midpointCartographic = this.geodesic.interpolateUsingFraction(0.5, scratch);\n      return Cesium.Cartesian3.fromRadians(midpointCartographic.longitude, midpointCartographic.latitude, height);\n    }\n  },\n  exportCoordDetails() {\n\n  }\n}\n</script>\n\n<style scoped>\n#container {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n</style>"],"sourceRoot":""}]}